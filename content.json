{"meta":{"title":"未拥的博客","subtitle":"","description":"","author":"未拥","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"'模拟停车场问题'","slug":"模拟停车场问题","date":"2019-11-16T08:40:55.000Z","updated":"2019-11-16T09:38:32.690Z","comments":true,"path":"2019/11/16/模拟停车场问题/","link":"","permalink":"http://yoursite.com/2019/11/16/%E6%A8%A1%E6%8B%9F%E5%81%9C%E8%BD%A6%E5%9C%BA%E9%97%AE%E9%A2%98/","excerpt":"模拟停车场问题是一个很经典的案例，这个案例主要用到了栈和队列的知识，写程序最重要的一步就是框架的构建，只有好的框架才能写出好的程序，下面的代码中，基本每一步我都进行了注释，就是看一眼就知道什么意思的那种，希望能帮助到你们。(详细注释，超详细！！！)","text":"模拟停车场问题是一个很经典的案例，这个案例主要用到了栈和队列的知识，写程序最重要的一步就是框架的构建，只有好的框架才能写出好的程序，下面的代码中，基本每一步我都进行了注释，就是看一眼就知道什么意思的那种，希望能帮助到你们。(详细注释，超详细！！！) 问题描述设停车场内只有一个的停放n辆汽车的狭长通道，且只有一个大门可供汽车进出。汽车在停车场内按车辆到达时间的先后顺序，依次由北向南排列（大门在最南端，最先到达的第一辆车停放在车场的最北端），若车场内已停满n辆汽车，则后来的汽车只能在门外的便道上等候，一旦有车开走，则排在便道上的第一辆车即可开入；当停车场内某辆车要离开时，在它之后开入的车辆必须先退出车场为它让路，待该辆车开出大门外，其它车辆再按原次序进入车场，每辆停放在车场的车在它离开停车场时必须按它停留的时间长短交纳费用。试为停车场编制按上述要求进行管理的模拟程序。 基本要求以栈模拟停车场，以队列模拟车场外的便道，按照从终端读入的输入数据序列进行模拟管理。每一组输入数据包括三个数据项：汽车“到达”或“离去”信息、汽车牌照号码及到达或离去的时刻，对每一组输入数据进行操作后的输出数据为：若是车辆到达，则输出汽车在停车场内或便道上的停车位置；若是车离去；则输出汽车在停车场内停留的时间和应交纳的费用（在便道上停留的时间不收费）。栈以顺序结构实现，队列以链表实现。 算法思想分析设计题目《模拟停车管理系统》 设计目的 根据车辆所停留的时间进行计时收费 当有车辆要离开时，进行良好的调度 用栈来表示停车场，队列表示便道 显示停车场和便道上的车的信息 算法分析 模拟停车场的车辆进出需要输入车辆的信息，比如车辆的车牌号码、时间，因此，可以定义一个车辆信息结点类型和一个时间节点类型，在链式栈、链式队列中定义结点类型为车辆信息结点类型。 车辆到达的时候要录入车辆信息、到达时间，每进入一辆车都要判断停车场（栈）是否停满，若已满，则提示该车停到便道上等待；若未满，则进行栈的操作，即停进停车场。 车辆离开时，需要打印输出车辆的基本信息，如车位号、到达时间、离开时间、车牌号和应缴纳的费用。 车辆离开时，还要另外设计一个辅助栈，当一辆汽车要离开时，在其后的车辆要给他让道，让道的车辆需要暂时停放在这个辅助栈中，待车辆离开后，在辅助栈中的车辆再停进停车场。然后再判断便道上是否有车辆在等待，若有则进行入栈操作。 不常见函数说明注：其实是我没怎么见过的函数。。。（小声BB） scanf（输入控制符，输入参数） 功能：将从键盘输入的字符转化为输入控制符所规定格式的数据，然后存入以输入参数的值为地址的变量中。 puts（） 功能：puts()函数用来向标准输出设备(屏幕)输出字符串并换行，具体为:把字符串输出到标准输出设备，将’\\0’转换为回车换行。其调用方式为，puts(s);其中s为字符串字符(字符串数组名或字符串指针)。 flushall（） 功能：清除所有缓冲区 gets（） 头文件：stdio.h 功能：从stdin流中读取字符串，直至接受到换行符或EOF时停止，并将读取的结果存放在str指针所指向的字符数组中。换行符不作为读取串的内容，读取的换行符被转换为null值，并由此来结束字符串。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242#include \"stdafx.h\"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;#define MAX 10 //车库容量#define price 0.05 //每车每分钟费用typedef struct time&#123; int hour; int min;&#125;Time; //时间结点typedef struct node&#123; char num[10]; //车牌号 Time reach; //进入停车场的时间 Time leave; //离开停车场的时间&#125;CarNode; //车辆信息结点typedef struct NODE&#123; //栈结构体定义 CarNode *stack[MAX +1]; int top;&#125;SeqStackCar; //模拟车站typedef struct car&#123; //队列结构体定义 CarNode *data; struct car *next;&#125;QueueNode; //队列结点typedef struct Node&#123; QueueNode *head; QueueNode *rear;&#125;LinkQueueCar; //模拟通道/*--------------------------------------------*/void InitStack(SeqStackCar *); //初始化栈int InitQueue(LinkQueueCar *); //初始化便道（队列）int Arrival(SeqStackCar *,LinkQueueCar *);//车辆到达void Leave(SeqStackCar *,SeqStackCar *,LinkQueueCar *);//车辆离开void List(SeqStackCar,LinkQueueCar); //显示存车信息/*--------------------------------------------*/void main()&#123; SeqStackCar Enter,Temp; LinkQueueCar Wait; int ch; InitStack(&amp;Enter); //初始化车场 InitStack(&amp;Temp); //初始化让路的临时栈 InitQueue(&amp;Wait); //初始化通路 while(1) &#123; printf(\"\\n1.车辆到达\"); printf(\"2.车辆离开\"); printf(\"3.列表显示\"); printf(\"4.退出系统\\n\"); while(1) //如果输入合法则进行下一步，不合法则继续输入 &#123; scanf_s(\"%d\",&amp;ch); if(ch&gt;=1&amp;&amp;ch&lt;4) break; else printf(\"\\n请选择: 1|2|3|4.\"); &#125; switch(ch) &#123; case 1:Arrival(&amp;Enter,&amp;Wait);break; //车辆到达 case 2:Leave(&amp;Enter,&amp;Temp,&amp;Wait);break;//车辆离开 case 3:List(Enter,Wait);break; //列表打印信息 case 4:exit(0); //退出主程序 default:break; &#125; &#125;&#125;/*--------------------------------------------*/void InitStack(SeqStackCar *s) //初始化栈&#123; int i; s-&gt;top=0; for(i=0;i&lt;=MAX;i++) s-&gt;stack[s-&gt;top]=NULL;&#125;int InitQueue(LinkQueueCar *Q) //初始化便道&#123; Q-&gt;head=(QueueNode *)malloc(sizeof(QueueNode)); if(Q-&gt;head!=NULL) &#123; Q-&gt;head-&gt;next=NULL; Q-&gt;rear=Q-&gt;head; return (1); &#125; else return(-1);&#125;void PRINT(CarNode *p,int room) //打印出站车的信息&#123; int A1, A2,B1,B2; printf(\"\\n请输入离开的时间：/**:**/\"); scanf_s(\"%d:%d\",&amp;(p-&gt;leave.hour),&amp;(p-&gt;leave.min)); puts(p-&gt;num); printf(\"\\n其到达时间为：%d:%d\",p-&gt;reach.hour,p-&gt;reach.min); printf(\"离开时间为: %d:%d\",p-&gt;leave.hour,p-&gt;leave.min); A1=p-&gt;reach.hour; A2=p-&gt;reach.min; B1=p-&gt;leave.hour; B2=p-&gt;leave.min; printf(\"\\n应交费用为: %2.1f元\",((B1-A1)*60+(B2-A2))*price); free(p);&#125;int Arrival(SeqStackCar *Enter,LinkQueueCar *W) //车辆到达 &#123; CarNode *p; QueueNode *t; p=(CarNode *)malloc(sizeof(CarNode)); _flushall(); printf(\"\\n请输入车牌号(例:冀A1234):\"); gets_s(p-&gt;num); if(Enter-&gt;top&lt;MAX) //车场未满，车进车场 &#123; Enter-&gt;top++; printf(\"\\n车辆在车场第%d位置.\",Enter-&gt;top); printf(\"\\n请输入到达时间:/**:**/\"); scanf_s(\"%d:%d\",&amp;(p-&gt;reach.hour),&amp;(p-&gt;reach.min)); Enter-&gt;stack[Enter-&gt;top]=p; return(1); &#125; else //车场已满，车进便道 &#123; printf(\"\\n该车须在便道等待!\"); t=(QueueNode *)malloc(sizeof(QueueNode)); t-&gt;data=p; t-&gt;next=NULL; W-&gt;rear-&gt;next=t; W-&gt;rear=t; return(1); &#125;&#125;void Leave(SeqStackCar *Enter,SeqStackCar *Temp,LinkQueueCar *W)&#123; int room; CarNode *p,*t; QueueNode *q; //判断车场内是否有车 if(Enter-&gt;top&gt;0) //车场有车 &#123; while(1) //输入离开车辆的信息 &#123; printf(\"\\n请输入车在车场的位置/1--%d:\",Enter-&gt;top); //现在车场位置有1--Enter-&gt;top scanf_s(\"%d\",&amp;room); if(room&gt;=1&amp;&amp;room&lt;=Enter-&gt;top) break; &#125; while(Enter-&gt;top&gt;room) &#123; Temp-&gt;top++; //临时栈 Temp-&gt;stack[Temp-&gt;top]=Enter-&gt;stack[Enter-&gt;top]; //构造一个临时栈，用来存放该车后面的车辆 Enter-&gt;stack[Enter-&gt;top]=NULL; Enter-&gt;top--; &#125; p=Enter-&gt;stack[Enter-&gt;top]; //p指向要离开的车辆 Enter-&gt;stack[Enter-&gt;top]=NULL; Enter-&gt;top--; //要离开的车辆驶离 while(Temp-&gt;top&gt;=1) &#123; Enter-&gt;top++; //将临时栈的车辆一个个停进停车场 Enter-&gt;stack[Enter-&gt;top]=Temp-&gt;stack[Temp-&gt;top]; Temp-&gt;stack[Temp-&gt;top]=NULL; Temp-&gt;top--; &#125; PRINT(p,room); //打印出站车的信息 /*判断通道上是否有车以及车站是否已满*/ if((W-&gt;head!=W-&gt;rear) &amp;&amp; Enter-&gt;top&lt;MAX) //便道的车辆进入车场 &#123; q=W-&gt;head-&gt;next; //便道的第一辆车 t=q-&gt;data; Enter-&gt;top++; printf(\"\\n便道的%s号车进入车场第%d位置.\",t-&gt;num,Enter-&gt;top); printf(\"\\n请输入现在的时间/**:**/:\"); scanf_s(\"%d:%d\",&amp;(t-&gt;reach.hour),&amp;(t-&gt;reach.min)); W-&gt;head-&gt;next=q-&gt;next; if(q==W-&gt;rear) //如果便道上只有一辆车等待 W-&gt;rear=W-&gt;head; Enter-&gt;stack[Enter-&gt;top]=t; //将便道上的第一辆车停进停车场 free(q); //释放指针q &#125; else printf(\"\\n便道里没有车.\\n\"); &#125; else printf(\"\\n车场里没有车.\");&#125;void List1(SeqStackCar *S) //列表显示车场信息&#123; int i; if(S-&gt;top=0) //判断车场内是否有车 &#123; printf(\"\\n车场：\"); printf(\"\\n 位置 到达时间 车牌号\\n\"); for(i=1;i&lt;S-&gt;top;i++) &#123; printf(\"%d\",i); printf(\"%d:%d\",S-&gt;stack[i]-&gt;reach.hour,S-&gt;stack[i]-&gt;reach.min); puts(S-&gt;stack[i]-&gt;num); &#125; &#125; else printf(\"\\n车场里没有车\");&#125;void List2(LinkQueueCar *W) //列表显示便道信息&#123; QueueNode *p; p=W-&gt;head-&gt;next; //p为便道的头结点 if(W-&gt;head!=W-&gt;rear) //判断通道上是否有车 &#123; printf(\"\\n等待车辆的号码为：\"); while(p!=NULL) &#123; puts(p-&gt;data-&gt;num); p=p-&gt;next; &#125; &#125; else printf(\"\\n便道里没有车.\");&#125;void List(SeqStackCar S,LinkQueueCar W)&#123; int flag,tag; flag=1; while(flag) &#123; printf(\"\\n请选择 1|2|3：\"); printf(\"\\n1.车场\\n2.便道\\n3.返回\\n\"); while (1) &#123; scanf_s(\"%d\",&amp;tag); if(tag&gt;=1||tag&lt;=3) break; else printf(\"\\n请选择 1|2|3：\"); &#125; switch(tag) &#123; case 1:List1(&amp;S);break; //列表显示车场信息 case 2:List2(&amp;W);break; //列表显示便道信息 case 3:flag=0;break; default:break; &#125; &#125;&#125;","categories":[],"tags":[{"name":"c++ 模拟停车场管理 经典案例 详细注释","slug":"c-模拟停车场管理-经典案例-详细注释","permalink":"http://yoursite.com/tags/c-%E6%A8%A1%E6%8B%9F%E5%81%9C%E8%BD%A6%E5%9C%BA%E7%AE%A1%E7%90%86-%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B-%E8%AF%A6%E7%BB%86%E6%B3%A8%E9%87%8A/"}]},{"title":"用Java实现四则运算","slug":"用Java实现四则运算","date":"2019-11-13T12:57:43.000Z","updated":"2019-11-13T13:16:48.524Z","comments":true,"path":"2019/11/13/用Java实现四则运算/","link":"","permalink":"http://yoursite.com/2019/11/13/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/","excerpt":"我们有时希望程序能对分数（分子分母都是整数）进行四则运算，而且两个分数四则运算的结果仍是分数。分数也称为有理数，是我们很熟悉的一种数，这个实验要求用类实现对有理数的封装。有理数有两个重要的成员：分子和分母，另外还有重要的四则运算。","text":"我们有时希望程序能对分数（分子分母都是整数）进行四则运算，而且两个分数四则运算的结果仍是分数。分数也称为有理数，是我们很熟悉的一种数，这个实验要求用类实现对有理数的封装。有理数有两个重要的成员：分子和分母，另外还有重要的四则运算。 Rational(有理数)类： 两个int成员变量，numerator（分子）和denominator（分母）。 Rational add（Rational r）方法，加法运算 Rational sub（Rational r）方法，减法运算 Rational muti（Rational r）方法，乘法运算 Rational div（Rational r）方法，除法运算 具体代码如下： Rational类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package 四则运算;public class Rational &#123; int numerator,denominator; Rational()&#123;&#125; Rational(int a,int b)&#123; setNumeratorAndDenominator(a,b); &#125; void setNumeratorAndDenominator(int a,int b)&#123; //设置分子和分母 int c=f(Math.abs(a),Math.abs(b)); //计算最大公约数 numerator=a/c; denominator=b/c; if(numerator&lt;0 &amp;&amp; denominator&lt;0)&#123; numerator=-numerator; denominator=-denominator; &#125; &#125; int getNumerator()&#123; //获取分子 return numerator; &#125; int getDenominator()&#123; //获取分母 return denominator; &#125; int f(int a,int b)&#123; if(a&lt;b)&#123; //如果a&lt;b，则a和b互换值 int c=a; a=b; b=c; &#125; int r=a%b; while(r!=0)&#123; //一直运算下去，求最大公约数 a=b; b=r; r=a%b; &#125; return b; &#125; Rational add(Rational r)&#123; //加法运算 int a=r.getNumerator(); int b=r.getDenominator(); int newNumerator=numerator*b+denominator*a; //分子的运算 int newDenominator=denominator*b; //分母的运算 Rational result=new Rational(newNumerator,newDenominator); return result; &#125; Rational sub(Rational r)&#123; //减法运算 int a=r.getNumerator(); int b=r.getNumerator(); int newNumerator=numerator*b-denominator*a; //分子的运算 int newDenominator=denominator*b; //分母的运算 Rational result=new Rational(newNumerator,newDenominator); return result; &#125; Rational muti(Rational r)&#123; //乘法运算 int a=r.getNumerator(); int b=r.getNumerator(); int newNumerator=numerator*a; //分子的运算 int newDenominator=denominator*b; //分母的运算 Rational result=new Rational(newNumerator,newDenominator); return result; &#125; Rational div(Rational r)&#123; //除法运算 int a=r.getNumerator(); int b=r.getNumerator(); int newNumerator=numerator*b; //分子的运算 int newDenominator=denominator*a; //分母的运算 Rational result=new Rational(newNumerator,newDenominator); return result; &#125;&#125; Computer类 123456789101112131415161718192021222324252627282930package 四则运算;public class Computer &#123; public static void main(String args[])&#123; Rational r1; r1=new Rational(1,5); //创建分子、分母分别为1和5的有理数r1 Rational r2; r2=new Rational(3,2); //创建分子、分母分别为3和2的有理数r2 Rational result=r1.add(r2); //r1调用方法和r2做加法运算 int a=result.getNumerator(); //result调用方法返回自己的分子 int b=result.getDenominator(); //result调用方法返回自己的分母 double p=a; double q=b; double doubleResult=p/q; System.out.print(\"分数\"+r1.getNumerator()+\"/\"+r1.getDenominator()); System.out.print(\"与分数\"+r2.getNumerator()+\"/\"+r2.getDenominator()+\"的和等于\"); System.out.print(a+\"/\"+b+\"=\"+doubleResult); r1.setNumeratorAndDenominator(4, 7); r2.setNumeratorAndDenominator(-5, 20); result=r1.muti(r2); a=result.getNumerator(); b=result.getDenominator(); p=a; q=b; doubleResult=p/q; System.out.print(\"分数\"+r1.getNumerator()+\"/\"+r1.getDenominator()); System.out.print(\"与分数\"+r2.getNumerator()+\"/\"+r2.getDenominator()+\"的积等于\"); System.out.print(a+\"/\"+b+\"=\"+doubleResult); &#125;&#125; 注：Rational类和Computer类是处于同一个包中！","categories":[],"tags":[{"name":"Java 四则运算 分数的运算","slug":"Java-四则运算-分数的运算","permalink":"http://yoursite.com/tags/Java-%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97-%E5%88%86%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97/"}]},{"title":"《笑傲江湖》人物出场统计","slug":"《笑傲江湖》人物出场统计","date":"2019-11-13T11:49:16.000Z","updated":"2019-11-13T12:07:14.491Z","comments":true,"path":"2019/11/13/《笑傲江湖》人物出场统计/","link":"","permalink":"http://yoursite.com/2019/11/13/%E3%80%8A%E7%AC%91%E5%82%B2%E6%B1%9F%E6%B9%96%E3%80%8B%E4%BA%BA%E7%89%A9%E5%87%BA%E5%9C%BA%E7%BB%9F%E8%AE%A1/","excerpt":"本文是关于jieba库使用的一个经典案例，《笑傲江湖》人物出场统计，输出人物出场排名前十的名字。","text":"本文是关于jieba库使用的一个经典案例，《笑傲江湖》人物出场统计，输出人物出场排名前十的名字。 安装jieba库cmd输入：pip3 install jieba 《笑傲江湖》人物出场统计人物出场统计涉及对词汇的统计。中文文章需要分词才能进行词频统计，这需要用到jieba库。《笑傲江湖》文本保存为xajh.text。实现代码如下： 12345678910111213141516171819202122232425import jiebaexcludes=&#123;\"甚么\",\"说道\",\"自己\",\"一个\",\"师父\",\"剑法\",\"咱们\",\"弟子\",\"一声\",\"不是\",\"恒山\",\"他们\",\"长剑\",\"出来\",\"不知\",\"知道\",\"武功\",\"二人\",\"只是\",\"突然\",\"嵩山\",\"我们\",\"心想\",\"如此\",\"倘若\",\"如何\",\"你们\",\"便是\"&#125;filename=\"\" #定义一个空字符串filename=r\"C:\\Users\\pc\\AppData\\Local\\Programs\\Python\\python例子\\xajh.txt\"#文件夹位置txt=open(filename,'r',encoding='utf-8').read()words=jieba.lcut(txt)counts=&#123;&#125; #定义counts为一个空集合for word in words: if len(word) == 1: #排除单个字符的分词结果 continue elif word == \"大师哥\" or word == \"冲儿\" or word == \"冲哥\" or word == \"令狐大哥\" or word == \"令狐掌门\": rword=\"令狐冲\" elif word == \"师妹\": rword=\"盈盈\" else: rword=word counts[rword]=counts.get(rword,0) +1 #如果word在counts中，则返回word对应的值，否则返回0for word in excludes: del(counts[word]) #排除词库excludesitems = list(counts.items()) #将字典转换为记录列表items.sort(key=lambda x:x[1],reverse=True) #以记录第二列排序for i in range(10): word,count=items[i] print(\"&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;\".format(word,count)) 上面代码是加入了排除词库excludes的代码，一开始分词频率最高的是“甚么”，“说道”之类的，这就需要我们加入排除词库excludes，并一点点扩大，排除那些人名无关的词汇。最后输出结果如下：（本人不太清楚笑傲江湖的人物关系构造，可能会出现人物重叠，结果仅供参考）","categories":[],"tags":[{"name":"jieba库案例","slug":"jieba库案例","permalink":"http://yoursite.com/tags/jieba%E5%BA%93%E6%A1%88%E4%BE%8B/"}]},{"title":"hexo搭建博客","slug":"hexo搭建博客","date":"2019-11-11T11:35:46.773Z","updated":"2019-11-12T13:33:43.119Z","comments":true,"path":"2019/11/11/hexo搭建博客/","link":"","permalink":"http://yoursite.com/2019/11/11/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"title: hexo搭建博客date: 2019-11-11 19:35:46tags: hexo搭建博客 个人博客这个事情不管是社招还是校招，对你的加分项可以说是非常非常大的，所以说IT的嘛，程序猿应该有一个自己的个人博客。 ​ 搭建博客的过程中肯定会出现各种各样的问题，首先不要畏惧它，大不了再重头再来。 ​ 下面是我从小白一点一点用hexo搭建起来的博客的步骤，我感觉还是比较详细的，希望能给大家带来帮助叭！","text":"title: hexo搭建博客date: 2019-11-11 19:35:46tags: hexo搭建博客 个人博客这个事情不管是社招还是校招，对你的加分项可以说是非常非常大的，所以说IT的嘛，程序猿应该有一个自己的个人博客。 ​ 搭建博客的过程中肯定会出现各种各样的问题，首先不要畏惧它，大不了再重头再来。 ​ 下面是我从小白一点一点用hexo搭建起来的博客的步骤，我感觉还是比较详细的，希望能给大家带来帮助叭！ 准备工作1. 安装node.js​ 安装地址：nodejs.org cmd查看node是否安装上了，node -v，出现了版本信息就是安装成功了 2. 安装Git​ 下载地址：https://git-scm.com/download/win cmd查看是否安装成功，输入git -version，有版本信息就是安装成功了 3. 注册GitHub​ 去GitHub官网注册就好啦，很简单的 4. 安装npm​ npm国内下载速度不太行，可选用淘宝镜像的方式： ​ npm install -g cnpm –registry=https://registry.npm.taobao.org ​ cmd查看是否安装成功，输入cnpm -v，有版本信息就是安装成功了 5. 安装hexo​ cnpm install -g hexo-cli ​ cmd查看是否安装成功，输入hexo -v验证是否安装成功 进入正题一.部署环境​ 1. 首先打开cmd ​ 2. 进入一个盘符之后，输入mkdir blog创建blog子目录，然后去查看是否创建成功，成功则进行下一步 ​ 3. 输入hexo init初始化博客，自动生成博客基础的各个文件，以后博客都是基于这个做 ​ ​ ​ 4. 显示这个样子就是安装成功了 ​ ​ 5. 自动创建的文件如图所示，点开看看创建成功了没有，失败了也没事，大不了重头再来 ​ 6. 输入hexo server启动博客 ​ 7. 标注的地方就是本地预览的地址 ​ 8. 接下来创建一个自己的博客，hexo new “我的第一篇博客文章”，引号里面就是文章的题目， 接下来就是编辑文件了，我个人建议使用Typora，这个软件编辑文档，插入代码图片都比较方便。 ​ 9. 再次生成博客 ​ hexo clean（清理一下） ​ hexo g（重新生成） ​ hexo s（在本地访问预览） 二.接下来演示如何将自己博客部署到GitHub上公开使用​ 1. 登陆GitHub ​ ​ 1.1 用户部署个人博客的GitHub仓库的命名必须符合要求才行，例如：xxx.github.io，xxx是你的名字。 ​ 1.2 描述一下这个文章 ​ 1.3 创建确定 ​ 2. 在cmd中输入npm install hexo-deployer-git –save，这个是Git的部署插件 ​ 3. 修改_config.yml文件 ​ notepad _config.yml,打开文件，拉到最下面，修改如图所示，repo后面是自己仓库的地址,注：冒号后面有一个空格！！！一定要打上空格！！！ ​ 4. 部署到远端：hexo d 三.如何更换博客主题 向大家推荐一个比较好用的主题地址： github.com/litten/hexo-theme-yilia 下载该主题 cmd输入git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia (这个仓库下载的可能比较慢，耐心等待呀) 修改_config.yml cmd输入notepad _config.yml,打开文件修改主题为yilia hexo clean 清理一下 hexo g 重新生成 hexo s 在本地预览 hexo d 上传（可能不会立马更新，等待一下再刷新） 图片乱码的问题 安装引入图片的插件： cmd输入cnpm install https://github.com/CodeFalling/hexo-asset-image –save 输入notepad _config.yml 将post_asset_folder:false改为post_asset_folder:true 运行hexo new ‘xxx’ xxx为你文章的题目，运行之后会出现一个同名的文件夹，将需要上传的图像放在该文件夹中，图像格式： 1![](/图片名字.图片格式)","categories":[],"tags":[]}]}